"""
ÌååÏùºÎ≥Ñ ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Î™®Îìà
"""

import logging
import aiofiles
from pathlib import Path
from typing import List, Dict, Any
import PyPDF2
from docx import Document

from .dependencies import (
    PDFMINER_AVAILABLE, XLRD_AVAILABLE, OPENPYXL_AVAILABLE, PYTHON_PPTX_AVAILABLE
)
from .text_utils import TextUtils
from .constants import ENCODINGS

if PDFMINER_AVAILABLE:
    from pdfminer.high_level import extract_text

if OPENPYXL_AVAILABLE and XLRD_AVAILABLE :
    from openpyxl import load_workbook
    import xlrd

if PYTHON_PPTX_AVAILABLE:
    from pptx import Presentation

logger = logging.getLogger("document-processor")

class DocumentExtractor:
    """Î¨∏ÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, ocr_processor, config_manager):
        self.ocr_processor = ocr_processor
        self.config_manager = config_manager
    
    # PDF Í¥ÄÎ†® Î©îÏÑúÎìúÎì§
    async def extract_text_from_pdf(self, file_path: str) -> str:
        """PDF ÌååÏùºÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (Ïã§ÏãúÍ∞Ñ ÏÑ§Ï†ïÏóê Îî∞Îùº ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú ÎòêÎäî OCR)"""
        try:
            current_config = self.config_manager.get_current_image_text_config()
            provider = current_config.get('provider', 'no_model')
            
            logger.info(f"üîÑ Real-time PDF processing with provider: {provider}")
            
            # no_modelÏù∏ Í≤ΩÏö∞ÏóêÎßå Í∏∞Î≥∏ ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú
            if provider == 'no_model':
                logger.info("Using text extraction mode (no_model)")
                
                # 1Îã®Í≥Ñ: pdfminer ÏãúÎèÑ
                if PDFMINER_AVAILABLE:
                    logger.info(f"Using pdfminer for {file_path}")
                    try:
                        text = extract_text(file_path)
                        cleaned_text = TextUtils.clean_text(text)
                        if len(cleaned_text.strip()) > 100:
                            logger.info(f"Text extracted via pdfminer: {len(cleaned_text)} chars")
                            return cleaned_text
                    except Exception as e:
                        logger.warning(f"pdfminer failed: {e}")
                        
                # 2Îã®Í≥Ñ: PyPDF2 fallback
                logger.info(f"Using PyPDF2 fallback for {file_path}")
                text = await self._extract_text_from_pdf_fallback(file_path)
                logger.info(f"Text extracted via PyPDF2: {len(text)} chars")
                return text
            
            else:
                # openai, vllm Îì± Îã§Î•∏ ÌîÑÎ°úÎ∞îÏù¥ÎçîÏù∏ Í≤ΩÏö∞ Î¨¥Ï°∞Í±¥ OCR
                logger.info(f"Using OCR mode with provider: {provider}")
                return await self._extract_text_from_pdf_via_ocr(file_path)
                
        except Exception as e:
            logger.error(f"PDF processing failed: {e}")
            
            # ÏóêÎü¨ Î∞úÏÉùÏãúÏóêÎèÑ Ïã§ÏãúÍ∞Ñ ÏÑ§Ï†ïÏóê Îî∞Îùº Ï≤òÎ¶¨
            current_config = self.config_manager.get_current_image_text_config()
            provider = current_config.get('provider', 'no_model')
            
            if provider == 'no_model':
                try:
                    return await self._extract_text_from_pdf_fallback(file_path)
                except:
                    return "[PDF ÌååÏùº: ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Ï§ë Ïò§Î•ò Î∞úÏÉù]"
            else:
                return await self._extract_text_from_pdf_via_ocr(file_path)

    async def _extract_text_from_pdf_fallback(self, file_path: str) -> str:
        """PDF ÌååÏùºÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (PyPDF2 fallback)"""
        text = ""
        try:
            with open(file_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                for page_num, page in enumerate(pdf_reader.pages):
                    page_text = page.extract_text()
                    if page_text:
                        text += f"\n=== ÌéòÏù¥ÏßÄ {page_num + 1} ===\n"
                        text += page_text + "\n"
            return TextUtils.clean_text(text)
        except Exception as e:
            logger.error(f"Error extracting text from PDF {file_path}: {e}")
            raise
    
    async def _extract_text_from_pdf_via_ocr(self, file_path: str) -> str:
        """PDFÎ•º Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò ÌõÑ Î∞∞Ïπò OCR Î©îÏÑúÎìú ÏÇ¨Ïö©"""
        try:
            current_config = self.config_manager.get_current_image_text_config()
            if not self.config_manager.is_image_text_enabled(current_config):
                logger.warning("OCR is disabled, falling back to text extraction")
                return await self._extract_text_from_pdf_fallback(file_path)
            
            logger.info(f"Converting PDF to images for OCR: {file_path}")
            
            image_files = await self.ocr_processor.convert_pdf_to_images(file_path)
            
            if not image_files:
                logger.warning("Failed to convert PDF to images, falling back to text extraction")
                return await self._extract_text_from_pdf_fallback(file_path)
            
            try:
                batch_size = current_config.get('batch_size', 1)
                logger.info(f"Processing {len(image_files)} pages with batch size: {batch_size}")
                
                page_texts = await self.ocr_processor.convert_images_to_text_batch(image_files, batch_size)
                
                # Í≤∞Í≥º Ï°∞Ìï©
                all_text = ""
                for i, page_text in enumerate(page_texts):
                    if not page_text.startswith("[Ïù¥ÎØ∏ÏßÄ ÌååÏùº:"):
                        all_text += f"\n=== ÌéòÏù¥ÏßÄ {i+1} (OCR) ===\n"
                        all_text += page_text + "\n"
                    else:
                        logger.warning(f"OCR failed for page {i+1}: {page_text}")
                       
            finally:
                # ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
                for temp_file in image_files:
                    try:
                        import os
                        os.unlink(temp_file)
                    except:
                        pass
            
            if all_text.strip():
                logger.info(f"Successfully extracted text via batch OCR: {len(all_text)} chars")
                return TextUtils.clean_text(all_text)
            else:
                logger.warning("OCR failed, falling back to text extraction")
                return await self._extract_text_from_pdf_fallback(file_path)
                
        except Exception as e:
            logger.error(f"OCR processing failed for {file_path}: {e}")
            logger.warning("OCR failed, falling back to text extraction")
            return await self._extract_text_from_pdf_fallback(file_path)

    # DOCX Í¥ÄÎ†® Î©îÏÑúÎìúÎì§
    async def extract_text_from_docx(self, file_path: str) -> str:
        """DOCX ÌååÏùºÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (Ïã§ÏãúÍ∞Ñ ÏÑ§Ï†ïÏóê Îî∞Îùº ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú ÎòêÎäî OCR)"""
        try:
            current_config = self.config_manager.get_current_image_text_config()
            provider = current_config.get('provider', 'no_model')
            
            logger.info(f"üîÑ Real-time DOCX processing with provider: {provider}")
            
            if provider == 'no_model':
                logger.info("Using DOCX text extraction mode (no_model)")
                return await self._extract_text_from_docx_fallback(file_path)
            
            else:
                logger.info(f"Using DOCX OCR mode with provider: {provider}")
                return await self._extract_text_from_docx_via_ocr(file_path)
                
        except Exception as e:
            logger.error(f"DOCX processing failed: {e}")
            
            current_config = self.config_manager.get_current_image_text_config()
            provider = current_config.get('provider', 'no_model')
            
            if provider == 'no_model':
                try:
                    return await self._extract_text_from_docx_fallback(file_path)
                except:
                    return "[DOCX ÌååÏùº: ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Ï§ë Ïò§Î•ò Î∞úÏÉù]"
            else:
                try:
                    logger.warning("DOCX OCR failed, trying basic text extraction")
                    return await self._extract_text_from_docx_fallback(file_path)
                except:
                    return "[DOCX ÌååÏùº: OCR Î∞è ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Î™®Îëê Ïã§Ìå®]"

    async def _extract_text_from_docx_via_ocr(self, file_path: str) -> str:
        """DOCXÎ•º Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò ÌõÑ Î∞∞Ïπò OCR Ï≤òÎ¶¨"""
        try:
            current_config = self.config_manager.get_current_image_text_config()
            if not self.config_manager.is_image_text_enabled(current_config):
                logger.warning("OCR is disabled for DOCX, falling back to text extraction")
                return await self._extract_text_from_docx_fallback(file_path)
            
            logger.info(f"Converting DOCX to images for OCR: {file_path}")
            
            image_files = await self.ocr_processor.convert_docx_to_images(file_path)
            
            if not image_files:
                logger.warning("Failed to convert DOCX to images, falling back to text extraction")
                return await self._extract_text_from_docx_fallback(file_path)
            
            try:
                batch_size = current_config.get('batch_size', 1)
                logger.info(f"Processing {len(image_files)} DOCX pages with batch size: {batch_size}")
                
                page_texts = await self.ocr_processor.convert_images_to_text_batch(image_files, batch_size)
                
                # Í≤∞Í≥º Ï°∞Ìï©
                all_text = ""
                for i, page_text in enumerate(page_texts):
                    if not page_text.startswith("[Ïù¥ÎØ∏ÏßÄ ÌååÏùº:"):
                        all_text += f"\n=== ÌéòÏù¥ÏßÄ {i+1} (OCR) ===\n"
                        all_text += page_text + "\n"
                    else:
                        logger.warning(f"OCR failed for DOCX page {i+1}: {page_text}")
                        
            finally:
                # ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
                for temp_file in image_files:
                    try:
                        import os
                        os.unlink(temp_file)
                    except:
                        pass
            
            if all_text.strip():
                logger.info(f"Successfully extracted DOCX text via batch OCR: {len(all_text)} chars")
                return TextUtils.clean_text(all_text)
            else:
                logger.warning("DOCX OCR failed, falling back to text extraction")
                return await self._extract_text_from_docx_fallback(file_path)
                
        except Exception as e:
            logger.error(f"DOCX OCR processing failed for {file_path}: {e}")
            logger.warning("DOCX OCR failed, falling back to text extraction")
            return await self._extract_text_from_docx_fallback(file_path)

    async def _extract_text_from_docx_fallback(self, file_path: str) -> str:
        """DOCX ÌååÏùºÏóêÏÑú Í∏∞Î≥∏ ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (Í∏∞Ï°¥ Î∞©Î≤ï)"""
        try:
            doc = Document(file_path)
            text = ""
            processed_tables = set()
            
            # Î∞©Î≤ï 1: Î¨∏ÏÑúÏùò Î™®Îì† ÏöîÏÜåÎ•º ÏàúÏÑúÎåÄÎ°ú Ï≤òÎ¶¨ (Í≥†Í∏â Î∞©Î≤ï)
            try:
                for element in doc.element.body:
                    if element.tag.endswith('p'):
                        para_text = self._extract_paragraph_text(element, doc)
                        if para_text.strip():
                            text += para_text + "\n"
                            
                    elif element.tag.endswith('tbl'):
                        table_text = self._extract_table_text(element)
                        if table_text.strip():
                            text += "\n=== Ìëú ===\n" + table_text + "\n=== Ìëú ÎÅù ===\n\n"
                            processed_tables.add(table_text)
                
                logger.info("Successfully used advanced DOCX parsing method")
            except Exception as e:
                logger.warning(f"Advanced parsing failed, falling back to simple method: {e}")
                # Fallback: Í∞ÑÎã®Ìïú Î∞©Î≤ïÏúºÎ°ú Î™®Îì† Îã®ÎùΩ Ï∂îÏ∂ú
                text = ""
                for paragraph in doc.paragraphs:
                    if paragraph.text.strip():
                        text += paragraph.text + "\n"
            
            # Î∞©Î≤ï 2: Î™®Îì† ÌëúÎ•º ÌôïÏã§Ìûà Ï∂îÏ∂ú (Ï§ëÎ≥µ Ï†úÍ±∞)
            for i, table in enumerate(doc.tables):
                table_text = self._extract_simple_table_text(table)
                if table_text.strip():
                    # Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú ÌëúÏù∏ÏßÄ ÌôïÏù∏ (Í∞ÑÎã®Ìïú ÎπÑÍµê)
                    is_duplicate = any(
                        TextUtils.is_similar_table_text(table_text, processed) 
                        for processed in processed_tables
                    )
                    
                    if not is_duplicate:
                        text += f"\n=== Ìëú {i+1} ===\n" + table_text + "\n=== Ìëú ÎÅù ===\n\n"
                        processed_tables.add(table_text)
            
            logger.info(f"Extracted {len(processed_tables)} tables from DOCX")
            return TextUtils.clean_text(text)
        except Exception as e:
            logger.error(f"Error extracting text from DOCX {file_path}: {e}")
            raise

    def _extract_paragraph_text(self, para_element, doc) -> str:
        """Îã®ÎùΩÏóêÏÑú ÌÖçÏä§Ìä∏ÏôÄ Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥ Ï∂îÏ∂ú"""
        try:
            text = ""
            nsmap = doc.element.nsmap if hasattr(doc.element, 'nsmap') else {}
            
            for run in para_element.findall('.//w:r', nsmap):
                # ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú
                for text_elem in run.findall('.//w:t', nsmap):
                    if text_elem.text:
                        text += text_elem.text
                
                # Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥ Ï∂îÏ∂ú
                for drawing in run.findall('.//w:drawing', nsmap):
                    text += " [Ïù¥ÎØ∏ÏßÄ] "
                    
                    # Ïù¥ÎØ∏ÏßÄ ÏÑ§Î™Ö ÌÖçÏä§Ìä∏ Ï∞æÍ∏∞ (Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
                    try:
                        for desc in drawing.findall('.//wp:docPr', nsmap):
                            if desc.get('descr'):
                                text += f"[ÏÑ§Î™Ö: {desc.get('descr')}] "
                            elif desc.get('name'):
                                text += f"[Ïù¥Î¶Ñ: {desc.get('name')}] "
                    except:
                        pass
            
            return text
        except Exception as e:
            logger.debug(f"Error extracting paragraph text: {e}")
            # Fallback methods
            try:
                text_elements = para_element.findall('.//w:t', {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'})
                return ''.join([elem.text or '' for elem in text_elements])
            except:
                try:
                    return para_element.text or ""
                except:
                    return ""
    
    def _extract_table_text(self, table_element) -> str:
        """Ìëú ÏöîÏÜåÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú"""
        try:
            text = ""
            ns = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
            
            for row in table_element.findall('.//w:tr', ns):
                row_text = []
                for cell in row.findall('.//w:tc', ns):
                    cell_text = ""
                    for text_elem in cell.findall('.//w:t', ns):
                        if text_elem.text:
                            cell_text += text_elem.text
                    row_text.append(cell_text.strip())
                
                if any(cell.strip() for cell in row_text):
                    text += " | ".join(row_text) + "\n"
            
            return text
        except Exception as e:
            logger.debug(f"Error extracting table text: {e}")
            return ""
    
    def _extract_simple_table_text(self, table) -> str:
        """python-docx Table Í∞ùÏ≤¥ÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú"""
        try:
            text = ""
            for row in table.rows:
                row_text = []
                for cell in row.cells:
                    cell_text = cell.text.strip()
                    row_text.append(cell_text)
                
                if any(cell.strip() for cell in row_text):
                    text += " | ".join(row_text) + "\n"
            
            return text
        except Exception as e:
            logger.debug(f"Error extracting simple table text: {e}")
            return ""

    # PPT Í¥ÄÎ†® Î©îÏÑúÎìúÎì§
    async def extract_text_from_ppt(self, file_path: str) -> str:
        """PPT ÌååÏùºÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (Ïã§ÏãúÍ∞Ñ ÏÑ§Ï†ïÏóê Îî∞Îùº ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú ÎòêÎäî OCR)"""
        try:
            current_config = self.config_manager.get_current_image_text_config()
            provider = current_config.get('provider', 'no_model')
            
            logger.info(f"üîÑ Real-time PPT processing with provider: {provider}")
            
            if provider == 'no_model':
                logger.info("Using PPT text extraction mode (no_model)")
                return await self._extract_text_from_ppt_fallback(file_path)
            
            else:
                logger.info(f"Using PPT OCR mode with provider: {provider}")
                return await self._extract_text_from_ppt_via_ocr(file_path)
                
        except Exception as e:
            logger.error(f"PPT processing failed: {e}")
            
            current_config = self.config_manager.get_current_image_text_config()
            provider = current_config.get('provider', 'no_model')
            
            if provider == 'no_model':
                try:
                    return await self._extract_text_from_ppt_fallback(file_path)
                except:
                    return "[PPT ÌååÏùº: ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Ï§ë Ïò§Î•ò Î∞úÏÉù]"
            else:
                try:
                    logger.warning("PPT OCR failed, trying basic text extraction")
                    return await self._extract_text_from_ppt_fallback(file_path)
                except:
                    return "[PPT ÌååÏùº: OCR Î∞è ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Î™®Îëê Ïã§Ìå®]"

    async def _extract_text_from_ppt_via_ocr(self, file_path: str) -> str:
        """PPTÎ•º Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò ÌõÑ Î∞∞Ïπò OCR Ï≤òÎ¶¨"""
        try:
            current_config = self.config_manager.get_current_image_text_config()
            if not self.config_manager.is_image_text_enabled(current_config):
                logger.warning("OCR is disabled for PPT, falling back to text extraction")
                return await self._extract_text_from_ppt_fallback(file_path)
            
            logger.info(f"Converting PPT to images for OCR: {file_path}")
            
            image_files = await self.ocr_processor.convert_ppt_to_images(file_path)
            
            if not image_files:
                logger.warning("Failed to convert PPT to images, falling back to text extraction")
                return await self._extract_text_from_ppt_fallback(file_path)
            
            try:
                batch_size = current_config.get('batch_size', 1)
                logger.info(f"Processing {len(image_files)} PPT slides with batch size: {batch_size}")
                
                slide_texts = await self.ocr_processor.convert_images_to_text_batch(image_files, batch_size)
                
                # Í≤∞Í≥º Ï°∞Ìï©
                all_text = ""
                for i, slide_text in enumerate(slide_texts):
                    if not slide_text.startswith("[Ïù¥ÎØ∏ÏßÄ ÌååÏùº:"):
                        all_text += f"\n=== Ïä¨ÎùºÏù¥Îìú {i+1} (OCR) ===\n"
                        all_text += slide_text + "\n"
                    else:
                        logger.warning(f"OCR failed for PPT slide {i+1}: {slide_text}")
                        
            finally:
                # ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
                for temp_file in image_files:
                    try:
                        import os
                        os.unlink(temp_file)
                    except:
                        pass
            
            if all_text.strip():
                logger.info(f"Successfully extracted PPT text via batch OCR: {len(all_text)} chars")
                return TextUtils.clean_text(all_text)
            else:
                logger.warning("PPT OCR failed, falling back to text extraction")
                return await self._extract_text_from_ppt_fallback(file_path)
                
        except Exception as e:
            logger.error(f"PPT OCR processing failed for {file_path}: {e}")
            logger.warning("PPT OCR failed, falling back to text extraction")
            return await self._extract_text_from_ppt_fallback(file_path)

    async def _extract_text_from_ppt_fallback(self, file_path: str) -> str:
        """PPT ÌååÏùºÏóêÏÑú Í∏∞Î≥∏ ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (python-pptx ÏÇ¨Ïö©)"""
        if not PYTHON_PPTX_AVAILABLE:
            raise Exception("python-pptx is required for PPT file processing but is not available")
        
        try:
            prs = Presentation(file_path)
            text = ""
            
            for slide_num, slide in enumerate(prs.slides):
                logger.info(f"Processing slide {slide_num + 1}/{len(prs.slides)}")
                
                # Ïä¨ÎùºÏù¥Îìú Ï†úÎ™© Ï∂îÍ∞Ä
                text += f"\n=== Ïä¨ÎùºÏù¥Îìú {slide_num + 1} ===\n"
                
                # Ïä¨ÎùºÏù¥ÎìúÏùò Î™®Îì† ÎèÑÌòïÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú
                slide_content = ""
                tables_found = 0
                
                for shape in slide.shapes:
                    # ÌÖçÏä§Ìä∏ ÎèÑÌòï Ï≤òÎ¶¨
                    if hasattr(shape, "text") and shape.text.strip():
                        slide_content += shape.text + "\n"
                    
                    # Ìëú Ï≤òÎ¶¨
                    elif hasattr(shape, "table"):
                        tables_found += 1
                        slide_content += f"\n--- Ìëú {tables_found} ---\n"
                        
                        table = shape.table
                        for row in table.rows:
                            row_text = []
                            for cell in row.cells:
                                cell_text = cell.text.strip()
                                row_text.append(cell_text)
                            
                            if any(cell.strip() for cell in row_text):
                                slide_content += " | ".join(row_text) + "\n"
                        
                        slide_content += f"--- Ìëú {tables_found} ÎÅù ---\n\n"
                    
                    # Ï∞®Ìä∏ÎÇò Îã§Î•∏ Í∞ùÏ≤¥Ïùò Í≤ΩÏö∞ ÌÉÄÏûÖ Ï†ïÎ≥¥Îßå Ï∂îÍ∞Ä
                    elif hasattr(shape, "chart"):
                        slide_content += "[Ï∞®Ìä∏ Í∞ùÏ≤¥]\n"
                    elif hasattr(shape, "picture"):
                        slide_content += "[Ïù¥ÎØ∏ÏßÄ Í∞ùÏ≤¥]\n"
                
                # Ïä¨ÎùºÏù¥Îìú ÎÖ∏Ìä∏ Ï∂îÍ∞Ä (ÏûàÎäî Í≤ΩÏö∞)
                if hasattr(slide, "notes_slide") and slide.notes_slide.notes_text_frame:
                    notes_text = slide.notes_slide.notes_text_frame.text.strip()
                    if notes_text:
                        slide_content += f"\n[Ïä¨ÎùºÏù¥Îìú ÎÖ∏Ìä∏]\n{notes_text}\n"
                
                # Îπà Ïä¨ÎùºÏù¥ÎìúÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞Îßå Ï∂îÍ∞Ä
                if slide_content.strip():
                    text += slide_content + "\n"
                else:
                    text += "[Îπà Ïä¨ÎùºÏù¥Îìú]\n\n"
            
            logger.info(f"Extracted text from {len(prs.slides)} slides")
            return TextUtils.clean_text(text)
            
        except Exception as e:
            logger.error(f"Error extracting text from PPT {file_path}: {e}")
            raise

    # Í∏∞ÌÉÄ ÌååÏùº ÌòïÏãù Ï≤òÎ¶¨
    async def extract_text_from_excel(self, file_path: str) -> str:
        """Excel ÌååÏùºÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (openpyxl Î∞è xlrd ÏÇ¨Ïö©)"""
        if not (OPENPYXL_AVAILABLE and XLRD_AVAILABLE):
            raise Exception("openpyxl and xlrd are required for Excel file processing but are not available")
        
        try:
            text = ""
            
            # ÌååÏùº ÌôïÏû•ÏûêÏóê Îî∞Îùº Ï≤òÎ¶¨ Î∞©Î≤ï Í≤∞Ï†ï
            file_extension = file_path.lower().split('.')[-1]
            
            if file_extension in ['xlsx', 'xlsm']:
                # openpyxlÎ°ú .xlsx/.xlsm ÌååÏùº Ï≤òÎ¶¨
                workbook = load_workbook(file_path, read_only=True, data_only=True)
                
                for sheet_name in workbook.sheetnames:
                    logger.info(f"Processing sheet: {sheet_name}")
                    worksheet = workbook[sheet_name]
                    
                    # ÏãúÌä∏ Ïù¥Î¶Ñ Ï∂îÍ∞Ä
                    text += f"\n=== ÏãúÌä∏: {sheet_name} ===\n"
                    
                    # Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî ÌñâÍ≥º Ïó¥ Î≤îÏúÑ ÌôïÏù∏
                    if worksheet.max_row == 1 and worksheet.max_column == 1:
                        # Îπà ÏãúÌä∏Ïù∏ Í≤ΩÏö∞
                        text += "Îπà ÏãúÌä∏\n\n"
                        continue
                    
                    # Ï≤´ Î≤àÏß∏ ÌñâÏùÑ Ìó§ÎçîÎ°ú Ï≤òÎ¶¨
                    header_row = []
                    for col in range(1, worksheet.max_column + 1):
                        cell_value = worksheet.cell(row=1, column=col).value
                        if cell_value is not None:
                            header_row.append(str(cell_value))
                        else:
                            header_row.append("")
                    
                    if any(header_row):  # Ìó§ÎçîÍ∞Ä ÏûàÎäî Í≤ΩÏö∞
                        text += "Ïª¨Îüº: " + ", ".join(header_row) + "\n\n"
                    
                    # Îç∞Ïù¥ÌÑ∞ ÌñâÎì§ Ï≤òÎ¶¨ (Ìó§Îçî Ï†úÏô∏)
                    for row in range(2, worksheet.max_row + 1):
                        row_data = []
                        for col in range(1, worksheet.max_column + 1):
                            cell_value = worksheet.cell(row=row, column=col).value
                            if cell_value is not None:
                                row_data.append(str(cell_value))
                        
                        if row_data:  # Îπà ÌñâÏù¥ ÏïÑÎãå Í≤ΩÏö∞
                            row_text = " | ".join(row_data)
                            if row_text.strip():
                                text += row_text + "\n"
                    
                    text += "\n"
                
                workbook.close()
                
            elif file_extension == 'xls':
                # xlrdÎ°ú .xls ÌååÏùº Ï≤òÎ¶¨
                workbook = xlrd.open_workbook(file_path)
                
                for sheet_index in range(workbook.nsheets):
                    worksheet = workbook.sheet_by_index(sheet_index)
                    sheet_name = workbook.sheet_names()[sheet_index]
                    
                    logger.info(f"Processing sheet: {sheet_name}")
                    
                    # ÏãúÌä∏ Ïù¥Î¶Ñ Ï∂îÍ∞Ä
                    text += f"\n=== ÏãúÌä∏: {sheet_name} ===\n"
                    
                    if worksheet.nrows == 0:
                        text += "Îπà ÏãúÌä∏\n\n"
                        continue
                    
                    # Ï≤´ Î≤àÏß∏ ÌñâÏùÑ Ìó§ÎçîÎ°ú Ï≤òÎ¶¨
                    if worksheet.nrows > 0:
                        header_row = []
                        for col in range(worksheet.ncols):
                            try:
                                cell_value = worksheet.cell_value(0, col)
                                if cell_value:
                                    header_row.append(str(cell_value))
                                else:
                                    header_row.append("")
                            except IndexError:
                                break
                        
                        if any(header_row):  # Ìó§ÎçîÍ∞Ä ÏûàÎäî Í≤ΩÏö∞
                            text += "Ïª¨Îüº: " + ", ".join(header_row) + "\n\n"
                    
                    # Îç∞Ïù¥ÌÑ∞ ÌñâÎì§ Ï≤òÎ¶¨ (Ìó§Îçî Ï†úÏô∏)
                    for row in range(1, worksheet.nrows):
                        row_data = []
                        for col in range(worksheet.ncols):
                            try:
                                cell_value = worksheet.cell_value(row, col)
                                if cell_value:
                                    # xlrdÏóêÏÑú ÎÇ†Ïßú/ÏãúÍ∞Ñ Ï≤òÎ¶¨
                                    if worksheet.cell_type(row, col) == xlrd.XL_CELL_DATE:
                                        try:
                                            date_value = xlrd.xldate_as_tuple(cell_value, workbook.datemode)
                                            if date_value:
                                                from datetime import datetime
                                                dt = datetime(*date_value)
                                                row_data.append(dt.strftime("%Y-%m-%d %H:%M:%S"))
                                            else:
                                                row_data.append(str(cell_value))
                                        except xlrd.XLDateError:
                                            row_data.append(str(cell_value))
                                    else:
                                        row_data.append(str(cell_value))
                            except IndexError:
                                break
                        
                        if row_data:  # Îπà ÌñâÏù¥ ÏïÑÎãå Í≤ΩÏö∞
                            row_text = " | ".join(row_data)
                            if row_text.strip():
                                text += row_text + "\n"
                    
                    text += "\n"
            else:
                raise Exception(f"Unsupported Excel file format: {file_extension}")
            
            return TextUtils.clean_text(text)
            
        except Exception as e:
            logger.error(f"Error extracting text from Excel {file_path}: {e}")
            raise

    async def extract_text_from_text_file(self, file_path: str, file_type: str) -> str:
        """ÌÖçÏä§Ìä∏ Í∏∞Î∞ò ÌååÏùºÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (Îã§ÏñëÌïú Ïù∏ÏΩîÎî© ÏãúÎèÑ)"""
        from .constants import (
            CODE_TYPES, TEXT_TYPES, CONFIG_TYPES, SCRIPT_TYPES, 
            LOG_TYPES, WEB_TYPES
        )
        
        # ÌååÏùº Ïπ¥ÌÖåÍ≥†Î¶¨ Í≤∞Ï†ï
        if file_type in CODE_TYPES:
            category = 'code'
        elif file_type in (TEXT_TYPES + CONFIG_TYPES + SCRIPT_TYPES + LOG_TYPES + WEB_TYPES):
            category = 'text'
        else:
            category = 'text'
        
        for encoding in ENCODINGS:
            try:
                async with aiofiles.open(file_path, 'r', encoding=encoding) as file:
                    text = await file.read()
                
                logger.info(f"Successfully read {file_path} with {encoding} encoding")
                
                # ÌååÏùº Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Îî∞Îùº Îã§Î•∏ Ï†ïÎ¶¨ Î∞©Ïãù Ï†ÅÏö©
                if category == 'code':
                    return TextUtils.clean_code_text(text, file_type)
                else:
                    return TextUtils.clean_text(text)
                    
            except UnicodeDecodeError:
                logger.debug(f"Failed to read {file_path} with {encoding} encoding, trying next...")
                continue
            except Exception as e:
                logger.error(f"Error reading file {file_path} with {encoding} encoding: {e}")
                continue
        
        # Î™®Îì† Ïù∏ÏΩîÎî©Ïù¥ Ïã§Ìå®Ìïú Í≤ΩÏö∞
        raise Exception(f"Could not read file {file_path} with any supported encoding")